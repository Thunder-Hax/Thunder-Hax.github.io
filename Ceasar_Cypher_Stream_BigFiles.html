<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Encodeur / Décodeur Binaire (Optimisé mémoire)</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; }
#dropZone { width: 100%; height: 100px; border: 2px dashed #ccc; line-height: 100px;
  text-align: center; color: #aaa; margin-top: 20px; transition: 0.2s; }
#dropZone.dragover { border-color: #000; color: #000; }
textarea { width: 100%; box-sizing: border-box; font-family: monospace; margin-bottom:10px;}
button { margin: 5px; }
#progressContainer { display:none; width:100%; background:#eee; height:20px; margin-top:10px; }
#progressBar { width:0%; height:100%; background:#4caf50; text-align:center; color:white; line-height:20px; }
</style>
</head>
<body>

<h1>Encodeur / Décodeur (optimisé mémoire)</h1>

<div>
  <label>Nom du fichier pour sauvegarde :</label>
  <input type="text" id="fileName" placeholder="result.bin">
</div>

<div>
  <label>Ouvrir un fichier :</label>
  <input type="file" id="fileInput">
</div>

<h3>Texte / Fichier original :</h3>
<textarea id="originalContent" rows="10" placeholder="Tapez du texte ici ou chargez un fichier..."></textarea>

<div id="progressContainer">
  <div id="progressBar">0%</div>
</div>

<div id="dropZone">Glissez un fichier ici</div>

<div>
  <label>Type d'encodage :</label>
  <select id="encodingSelect">
    <option value="base64">Base64</option>
    <option value="hex">Hexadécimal</option>
    <option value="ceasar">César</option>
    <option value="hexbase64ceasarresult">Hex → Base64 → César</option>
  </select>
</div>

<div id="ceasarKeyContainer" style="display:none;">
  <label>Clé César :</label>
  <input type="number" id="ceasarKey" value="3">
</div>

<button id="encodeBtn">Encoder</button>
<button id="decodeBtn">Décoder</button>

<h3>Résultat :</h3>
<textarea id="resultContent" rows="10" placeholder="Le résultat apparaîtra ici..."></textarea>

<div>
  <button id="saveFileBtn">Sauvegarder le résultat</button>
</div>

<script>
const originalContent = document.getElementById('originalContent');
const resultContent = document.getElementById('resultContent');
const fileNameInput = document.getElementById('fileName');
const encodingSelect = document.getElementById('encodingSelect');
const ceasarKeyInput = document.getElementById('ceasarKey');
const ceasarKeyContainer = document.getElementById('ceasarKeyContainer');
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');
const saveFileBtn = document.getElementById('saveFileBtn');
const progressContainer = document.getElementById('progressContainer');
const progressBar = document.getElementById('progressBar');

let fileBlob = null;
let lastBinaryResult = null;

// --- Lecture optimisée en Blob ---
async function readFileInChunks(file, chunkSize = 4 * 1024 * 1024) { // 4 Mo
  const parts = [];
  let offset = 0;
  const total = file.size;
  progressContainer.style.display = "block";

  while (offset < total) {
    const slice = file.slice(offset, offset + chunkSize);
    parts.push(slice);
    offset += chunkSize;

    const percent = Math.min(100, Math.floor((offset / total) * 100));
    progressBar.style.width = percent + "%";
    progressBar.textContent = percent + "%";

    await new Promise(r => setTimeout(r, 0));
  }

  progressContainer.style.display = "none";
  return new Blob(parts);
}

// --- Conversion utils ---
function arrayBufferToHex(buffer) {
  return Array.from(new Uint8Array(buffer))
    .map(b => b.toString(16).padStart(2, '0')).join('');
}

function hexToArrayBuffer(hex) {
  const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b => parseInt(b, 16)));
  return bytes.buffer;
}

function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  const chunkSize = 0x8000;
  for (let i = 0; i < bytes.length; i += chunkSize)
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
  return btoa(binary);
}

function base64ToArrayBuffer(base64) {
  const binary = atob(base64);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}

function caesarShift(str, shift) {
  const a = 'a'.charCodeAt(0), A = 'A'.charCodeAt(0);
  return str.split('').map(ch => {
    if (/[a-z]/.test(ch)) return String.fromCharCode((ch.charCodeAt(0) - a + shift + 26) % 26 + a);
    if (/[A-Z]/.test(ch)) return String.fromCharCode((ch.charCodeAt(0) - A + shift + 26) % 26 + A);
    return ch;
  }).join('');
}

function textToUint8Array(str) { return new TextEncoder().encode(str); }
function uint8ArrayToText(arr) { return new TextDecoder().decode(arr); }

function randomFilename(base) {
  const rand = Math.floor(Math.random() * 100000);
  const parts = base.split('.');
  if (parts.length > 1) return parts[0] + "_" + rand + "." + parts.slice(1).join('.');
  return base + "_" + rand;
}

// --- Gestion fichier ---
async function handleFile(file) {
  originalContent.value = "Chargement du fichier (rapide, en flux)...";
  fileBlob = await readFileInChunks(file);
  originalContent.value = "Fichier prêt : " + file.name + " (" + (file.size / 1024 / 1024).toFixed(2) + " Mo)";
}

// --- Encode / Decode ---
async function process(operation) {
  if (!fileBlob && !originalContent.value.trim()) return alert("Aucun contenu !");
  const encoding = encodingSelect.value;
  const key = parseInt(ceasarKeyInput.value) || 0;
  let result = "";
  lastBinaryResult = null;

  try {
    // On lit tout le blob une seule fois ici
    const buffer = fileBlob
      ? await fileBlob.arrayBuffer()
      : textToUint8Array(originalContent.value).buffer;
    const input = new Uint8Array(buffer);

    if (operation === "encode") {
      if (encoding === "base64") {
        result = arrayBufferToBase64(input.buffer);
        lastBinaryResult = textToUint8Array(result);
      } else if (encoding === "hex") {
        result = arrayBufferToHex(input.buffer);
        lastBinaryResult = input;
      } else if (encoding === "ceasar") {
        result = caesarShift(uint8ArrayToText(input), key);
        lastBinaryResult = textToUint8Array(result);
      } else if (encoding === "hexbase64ceasarresult") {
        const hex = arrayBufferToHex(input.buffer);
        const base64 = btoa(hex); // Base64 correctement formée ici
        result = caesarShift(base64, key);
        lastBinaryResult = textToUint8Array(result);
      }
    } else {
      const text = uint8ArrayToText(input);
      if (encoding === "base64") {
        lastBinaryResult = new Uint8Array(base64ToArrayBuffer(text));
        result = uint8ArrayToText(lastBinaryResult);
      } else if (encoding === "hex") {
        lastBinaryResult = new Uint8Array(hexToArrayBuffer(text));
        result = uint8ArrayToText(lastBinaryResult);
      } else if (encoding === "ceasar") {
        result = caesarShift(text, -key);
        lastBinaryResult = textToUint8Array(result);
      } else if (encoding === "hexbase64ceasarresult") {
        const step1 = caesarShift(text, -key);
        const step2 = atob(step1); // Assurez-vous que step1 est bien en Base64 valide
        lastBinaryResult = new Uint8Array(hexToArrayBuffer(step2));
        result = uint8ArrayToText(lastBinaryResult);
      }
    }
  } catch (e) {
    result = "Erreur : " + e.message;
    console.error(e);
  }

  resultContent.value = result.slice(0, 10000);
  if (result.length > 10000) resultContent.value += "\n... (tronqué)";
}

// --- Sauvegarde ---
function saveResult() {
  if (!lastBinaryResult) return alert("Rien à sauvegarder !");
  let filename = fileNameInput.value || "result.bin";
  filename = randomFilename(filename);
  const blob = new Blob([lastBinaryResult], { type: "application/octet-stream" });
  const link = document.createElement("a");
  link.href = URL.createObjectURL(blob);
  link.download = filename;
  link.click();
  URL.revokeObjectURL(link.href);
}

// --- UI ---
encodingSelect.addEventListener("change", () => {
  ceasarKeyContainer.style.display = encodingSelect.value.includes("ceasar") ? "block" : "none";
});
fileInput.addEventListener("change", e => { if (e.target.files[0]) handleFile(e.target.files[0]); });
dropZone.addEventListener("dragover", e => { e.preventDefault(); dropZone.classList.add("dragover"); });
dropZone.addEventListener("dragleave", () => dropZone.classList.remove("dragover"));
dropZone.addEventListener("drop", e => {
  e.preventDefault(); dropZone.classList.remove("dragover");
  if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
});
document.getElementById("encodeBtn").addEventListener("click", () => process("encode"));
document.getElementById("decodeBtn").addEventListener("click", () => process("decode"));
saveFileBtn.addEventListener("click", saveResult);
</script>

</body>
</html>
